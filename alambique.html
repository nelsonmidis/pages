<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>🍺 Alambique Nuclear ☢️</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { width: 100%; height: 100%; font-family: sans-serif; }
    #root { width: 100%; height: 100%; }
    .safe-area-inset { padding-bottom: env(safe-area-inset-bottom); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">

    const { useState, useEffect, useCallback, useRef } = React;

    const useStoredState = (key, initialValue) => {
      const [value, setValue] = useState(() => {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : initialValue;
      });

      useEffect(() => {
        localStorage.setItem(key, JSON.stringify(value));
      }, [key, value]);

      return [value, setValue];
    };

    const AlambicGame = () => {
      const [gameState, setGameState] = useState('menu');
      const [score, setScore] = useState(0);
      const [highScore, setHighScore] = useStoredState('alambique-highscore', 0);
      const [level, setLevel] = useState(1);
      const [bottles, setBottles] = useState([]);
      const [trucks, setTrucks] = useState([]);
      const [reactorHeat, setReactorHeat] = useState(20);
      const [gameSpeed, setGameSpeed] = useState(1000);
      const [explosion, setExplosion] = useState(false);

      const gameAreaRef = useRef(null);
      const gameLoopRef = useRef(null);
      const bottleIdRef = useRef(0);
      const truckIdRef = useRef(0);

      const GAME_WIDTH = 350;
      const GAME_HEIGHT = 500;
      const BOTTLE_WIDTH = 25;
      const BOTTLE_HEIGHT = 35;
      const TRUCK_WIDTH = 70;
      const TRUCK_HEIGHT = 50;

      const generateBottle = useCallback(() => ({
        id: bottleIdRef.current++,
        x: Math.random() * (GAME_WIDTH - BOTTLE_WIDTH),
        y: -BOTTLE_HEIGHT,
        speed: 2 + level * 0.5,
        collected: false
      }), [level]);

      const generateTruck = useCallback(() => ({
        id: truckIdRef.current++,
        x: Math.random() * (GAME_WIDTH - TRUCK_WIDTH),
        y: GAME_HEIGHT - TRUCK_HEIGHT - 20,
        capacity: 3 + Math.floor(level / 2),
        bottles: 0,
        full: false
      }), [level]);

      const checkCollision = (bottle, truck) => {
        return bottle.x < truck.x + TRUCK_WIDTH &&
               bottle.x + BOTTLE_WIDTH > truck.x &&
               bottle.y < truck.y + TRUCK_HEIGHT &&
               bottle.y + BOTTLE_HEIGHT > truck.y;
      };

      const updateGame = useCallback(() => {
        if (gameState !== 'playing') return;

        setBottles(prevBottles => {
          const newBottles = prevBottles.map(b => ({...b, y: b.y + b.speed}))
            .filter(b => b.y < GAME_HEIGHT + 100 && !b.collected);

          setTrucks(prevTrucks => {
            const updatedTrucks = prevTrucks.map(truck => {
              if (truck.full) return truck;

              const colliding = newBottles.find(bottle =>
                !bottle.collected && checkCollision(bottle, truck));

              if (colliding) {
                colliding.collected = true;
                const newCount = truck.bottles + 1;
                const isFull = newCount >= truck.capacity;

                if (isFull) {
                  setScore(prev => prev + truck.capacity * 10);
                }

                return {...truck, bottles: newCount, full: isFull};
              }
              return truck;
            });

            const activeTrucks = updatedTrucks.filter(t => !t.full);
            if (activeTrucks.length === 0) {
              activeTrucks.push(generateTruck());
            }

            return activeTrucks;
          });

          const fallen = newBottles.filter(b => b.y > GAME_HEIGHT && !b.collected);
          if (fallen.length > 0) {
            setExplosion(true);
            setTimeout(() => {
              setGameState('gameOver');
              setExplosion(false);
            }, 1000);
          }

          return newBottles.filter(b => b.collected || b.y < GAME_HEIGHT + 50);
        });

        if (Math.random() < 0.05 + level * 0.01) {
          setBottles(prev => [...prev, generateBottle()]);
        }

        setReactorHeat(prev => Math.min(100, prev + 0.1));

        const newLevel = Math.floor(score / 200) + 1;
        if (newLevel > level) {
          setLevel(newLevel);
          setGameSpeed(prev => Math.max(300, prev - 50));
        }
      }, [gameState, level, score, generateBottle, generateTruck]);

      useEffect(() => {
        if (gameState === 'playing') {
          gameLoopRef.current = setInterval(updateGame, 50);
        } else {
          clearInterval(gameLoopRef.current);
        }
        return () => clearInterval(gameLoopRef.current);
      }, [gameState, updateGame]);

      const startGame = () => {
        setGameState('playing');
        setScore(0);
        setLevel(1);
        setBottles([]);
        setTrucks([generateTruck()]);
        setReactorHeat(20);
        setGameSpeed(1000);
        setExplosion(false);
      };

      const backToMenu = () => {
        if (score > highScore) {
          setHighScore(score);
        }
        setGameState('menu');
      };

      const handleTouchMove = e => {
        if (gameState !== 'playing') return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = gameAreaRef.current.getBoundingClientRect();
        const x = touch.clientX - rect.left;

        setTrucks(prev =>
          prev.map(t => ({...t, x: Math.max(0, Math.min(GAME_WIDTH - TRUCK_WIDTH, x - TRUCK_WIDTH / 2))}))
        );
      };

      const handleWheel = e => {
        if (gameState !== 'playing') return;
        e.preventDefault();
        const move = e.deltaY > 0 ? 20 : -20;
        setTrucks(prev =>
          prev.map(t => ({...t, x: Math.max(0, Math.min(GAME_WIDTH - TRUCK_WIDTH, t.x + move))}))
        );
      };

      if (gameState === 'menu') {
        return (
          <div style={{padding: 20}}>
            <h1>🍺 O ALAMBIQUE NUCLEAR!!! ☢️</h1>
            <p>Lula + Putin = Cachaça Explosiva!</p>
            <img src="https://github.com/nelsonmidis/pages/blob/master/lula%20normal.jpg?raw=true" alt="Lula" width="60" />
            <img src="https://github.com/nelsonmidis/pages/blob/master/putin%20melhor.jpg?raw=true" alt="Putin" width="60" />
            <p>🏆 Recorde: {highScore}</p>
            <button onClick={startGame}>🚀 COMEÇAR REVOLUÇÃO!</button>
          </div>
        );
      }

      if (gameState === 'gameOver') {
        return (
          <div style={{padding: 20}}>
            <h1>💥 DESASTRE NUCLEAR! 💥</h1>
            <p>Score: {score}</p>
            <p>Nível: {level}</p>
            <p>Recorde: {Math.max(score, highScore)}</p>
            <button onClick={startGame}>🔄 TENTAR NOVAMENTE</button>
            <button onClick={backToMenu}>🏠 MENU</button>
          </div>
        );
      }

      const redIntensity = Math.min(reactorHeat / 100, 1);
      const backgroundStyle = {
        background: `linear-gradient(to bottom, rgb(${30 + redIntensity * 200}, ${50 - redIntensity * 40}, ${120 - redIntensity * 100}),
                                           rgb(${20 + redIntensity * 180}, ${80 - redIntensity * 60}, ${40 - redIntensity * 30}))`,
        height: '100%',
        color: 'white'
      };

      return (
        <div style={backgroundStyle}>
          <div>🍾 Score: {score} | 📊 Nível: {level}</div>
          <div
            ref={gameAreaRef}
            onTouchMove={handleTouchMove}
            onWheel={handleWheel}
            style={{position: 'relative', width: GAME_WIDTH, height: GAME_HEIGHT, margin: '0 auto'}}
          >
            {bottles.map(b => (
              <img
                key={b.id}
                src="https://github.com/nelsonmidis/pages/blob/master/cachaca.webp?raw=true"
                alt="Cachaça"
                style={{
                  position: 'absolute',
                  left: b.x,
                  top: b.y,
                  width: BOTTLE_WIDTH,
                  height: BOTTLE_HEIGHT
                }}
              />
            ))}
            {trucks.map(t => (
              <div key={t.id} style={{
                position: 'absolute',
                left: t.x,
                top: t.y,
                width: TRUCK_WIDTH,
                height: TRUCK_HEIGHT
              }}>
                <img
                  src="https://github.com/nelsonmidis/pages/blob/master/caminhaoChines.png?raw=true"
                  alt="Caminhão"
                  style={{width: '100%', height: '100%'}}
                />
                <div style={{
                  position: 'absolute',
                  bottom: 0,
                  right: 0,
                  background: 'black',
                  color: 'white',
                  fontSize: 10,
                  padding: '2px'
                }}>
                  {t.bottles}/{t.capacity}
                </div>
              </div>
            ))}
            {explosion && (
              <div style={{
                position: 'absolute',
                inset: 0,
                background: 'rgba(255,0,0,0.7)',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                fontSize: 40
              }}>
                💥☢️💥
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<AlambicGame />);
  </script>
</body>
</html>
